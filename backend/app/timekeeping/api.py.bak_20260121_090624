from __future__ import annotations

from datetime import date, datetime, timezone
from typing import List, Optional

from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel, Field
from sqlalchemy.orm import Session

from app.db import SessionLocal
from app.timekeeping.models import (
    TkCrewLog,
    TkCrewLogMember,
    TkCrewWorkSegment,
    TkEmployee,
    TkVehicle,
    TkSite,
)

router = APIRouter(prefix="/timekeeping", tags=["timekeeping"])


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


def utcnow_naive() -> datetime:
    return datetime.now(timezone.utc).replace(tzinfo=None)


# -----------------------------
# Employees
# -----------------------------
class EmployeeCreate(BaseModel):
    full_name: str = Field(min_length=2, max_length=200)
    user_id: Optional[int] = None


class EmployeeOut(BaseModel):
    id: int
    full_name: str
    user_id: Optional[int]
    is_active: bool

    class Config:
        from_attributes = True


@router.post("/employees", response_model=EmployeeOut)
def create_employee(payload: EmployeeCreate, db: Session = Depends(get_db)):
    emp = TkEmployee(full_name=payload.full_name, user_id=payload.user_id, is_active=True)
    db.add(emp)
    db.commit()
    db.refresh(emp)
    return emp


@router.get("/employees", response_model=List[EmployeeOut])
def list_employees(db: Session = Depends(get_db)):
    return (
        db.query(TkEmployee)
        .filter(TkEmployee.is_active == True)
        .order_by(TkEmployee.full_name.asc())
        .all()
    )


# -----------------------------
# Vehicles
# -----------------------------
class VehicleCreate(BaseModel):
    plate: str = Field(min_length=2, max_length=32)
    make_model: Optional[str] = None
    navisoft_device_id: Optional[str] = None


class VehicleOut(BaseModel):
    id: int
    plate: str
    make_model: Optional[str]
    navisoft_device_id: Optional[str]
    is_active: bool

    class Config:
        from_attributes = True


@router.post("/vehicles", response_model=VehicleOut)
def create_vehicle(payload: VehicleCreate, db: Session = Depends(get_db)):
    v = TkVehicle(
        plate=payload.plate,
        make_model=payload.make_model,
        navisoft_device_id=payload.navisoft_device_id,
        is_active=True,
    )
    db.add(v)
    db.commit()
    db.refresh(v)
    return v


@router.get("/vehicles", response_model=List[VehicleOut])
def list_vehicles(db: Session = Depends(get_db)):
    return (
        db.query(TkVehicle)
        .filter(TkVehicle.is_active == True)
        .order_by(TkVehicle.plate.asc())
        .all()
    )


# -----------------------------
# Sites
# -----------------------------
class SiteAdHocCreate(BaseModel):
    name: str = Field(min_length=2, max_length=200)
    lat: float
    lng: float
    radius_m: int = 500


class SiteOut(BaseModel):
    id: int
    name: str
    lat: Optional[float]
    lng: Optional[float]
    radius_m: Optional[int]
    is_ad_hoc: bool

    class Config:
        from_attributes = True


@router.post("/sites/ad-hoc", response_model=SiteOut)
def create_site_ad_hoc(payload: SiteAdHocCreate, db: Session = Depends(get_db)):
    s = TkSite(
        name=payload.name,
        lat=payload.lat,
        lng=payload.lng,
        radius_m=payload.radius_m,
        is_ad_hoc=True,
    )
    db.add(s)
    db.commit()
    db.refresh(s)
    return s


@router.get("/sites", response_model=List[SiteOut])
def list_sites(db: Session = Depends(get_db)):
    return db.query(TkSite).order_by(TkSite.name.asc()).all()


# -----------------------------
# Crew logs
# -----------------------------
class CrewLogCreate(BaseModel):
    work_date: date
    vehicle_id: int
    created_by_employee_id: Optional[int] = None


class CrewLogOut(BaseModel):
    id: int
    work_date: date
    vehicle_id: int
    created_by_employee_id: Optional[int] = None

    class Config:
        from_attributes = True


@router.post("/crew-logs", response_model=CrewLogOut)
def create_crew_log(payload: CrewLogCreate, db: Session = Depends(get_db)):
    log = TkCrewLog(
        work_date=payload.work_date,
        vehicle_id=payload.vehicle_id,
        created_by_employee_id=payload.created_by_employee_id,
    )
    db.add(log)
    db.commit()
    db.refresh(log)
    return log


@router.get("/crew-logs", response_model=List[CrewLogOut])
def list_crew_logs(
    work_date: Optional[date] = None,
    vehicle_id: Optional[int] = None,
    db: Session = Depends(get_db),
):
    q = db.query(TkCrewLog)
    if work_date is not None:
        q = q.filter(TkCrewLog.work_date == work_date)
    if vehicle_id is not None:
        q = q.filter(TkCrewLog.vehicle_id == vehicle_id)
    return q.order_by(TkCrewLog.work_date.desc(), TkCrewLog.id.desc()).all()


# -----------------------------
# Members
# -----------------------------
class CrewMemberCreate(BaseModel):
    employee_id: int


class CrewMemberOut(BaseModel):
    id: int
    crew_log_id: int
    employee_id: int

    class Config:
        from_attributes = True


@router.post("/crew-logs/{log_id}/members", response_model=CrewMemberOut)
def add_member(log_id: int, payload: CrewMemberCreate, db: Session = Depends(get_db)):
    log = db.query(TkCrewLog).filter(TkCrewLog.id == log_id).first()
    if not log:
        raise HTTPException(status_code=404, detail="Crew log not found")

    m = TkCrewLogMember(crew_log_id=log_id, employee_id=payload.employee_id)
    db.add(m)
    db.commit()
    db.refresh(m)
    return m


@router.get("/crew-logs/{log_id}/members", response_model=List[CrewMemberOut])
def list_members(log_id: int, db: Session = Depends(get_db)):
    return (
        db.query(TkCrewLogMember)
        .filter(TkCrewLogMember.crew_log_id == log_id)
        .order_by(TkCrewLogMember.id.asc())
        .all()
    )


# -----------------------------
# Segments
# -----------------------------
class CrewSegmentCreate(BaseModel):
    site_id: int
    start_at: datetime
    end_at: Optional[datetime] = None


class CrewSegmentStart(BaseModel):
    site_id: int


class CrewSegmentClose(BaseModel):
    end_at: Optional[datetime] = None


class CrewSegmentOut(BaseModel):
    id: int
    crew_log_id: int
    site_id: int
    start_at: datetime
    end_at: Optional[datetime]
    start_lat: float
    start_lng: float
    end_lat: float
    end_lng: float

    class Config:
        from_attributes = True


def _get_log_or_404(db: Session, log_id: int) -> TkCrewLog:
    log = db.query(TkCrewLog).filter(TkCrewLog.id == log_id).first()
    if not log:
        raise HTTPException(status_code=404, detail="Crew log not found")
    return log


def _get_site_or_404(db: Session, site_id: int) -> TkSite:
    site = db.query(TkSite).filter(TkSite.id == site_id).first()
    if not site:
        raise HTTPException(status_code=404, detail="Site not found")
    if site.lat is None or site.lng is None:
        raise HTTPException(status_code=422, detail="Site is missing lat/lng")
    return site


def _get_open_segment(db: Session, log_id: int) -> Optional[TkCrewWorkSegment]:
    return (
        db.query(TkCrewWorkSegment)
        .filter(TkCrewWorkSegment.crew_log_id == log_id)
        .filter(TkCrewWorkSegment.end_at.is_(None))
        .first()
    )


@router.get("/crew-logs/{log_id}/segments", response_model=List[CrewSegmentOut])
def list_segments(log_id: int, db: Session = Depends(get_db)):
    return (
        db.query(TkCrewWorkSegment)
        .filter(TkCrewWorkSegment.crew_log_id == log_id)
        .order_by(TkCrewWorkSegment.id.asc())
        .all()
    )


@router.post("/crew-logs/{log_id}/segments", response_model=CrewSegmentOut)
def add_segment(log_id: int, payload: CrewSegmentCreate, db: Session = Depends(get_db)):
    _get_log_or_404(db, log_id)

    open_seg = _get_open_segment(db, log_id)
    if open_seg:
        raise HTTPException(
            status_code=409,
            detail=f"Open segment already exists (segment_id={open_seg.id}). Close it first.",
        )

    site = _get_site_or_404(db, payload.site_id)

    seg = TkCrewWorkSegment(
        crew_log_id=log_id,
        site_id=payload.site_id,
        start_at=payload.start_at,
        end_at=payload.end_at,
        start_lat=site.lat,
        start_lng=site.lng,
        end_lat=site.lat,
        end_lng=site.lng,
    )

    db.add(seg)
    db.commit()
    db.refresh(seg)
    return seg


@router.post("/crew-logs/{log_id}/segments/start", response_model=CrewSegmentOut)
def start_segment(log_id: int, payload: CrewSegmentStart, db: Session = Depends(get_db)):
    _get_log_or_404(db, log_id)

    open_seg = _get_open_segment(db, log_id)
    if open_seg:
        raise HTTPException(
            status_code=409,
            detail=f"Open segment already exists (segment_id={open_seg.id}). Close it first.",
        )

    site = _get_site_or_404(db, payload.site_id)
    now = utcnow_naive()

    seg = TkCrewWorkSegment(
        crew_log_id=log_id,
        site_id=payload.site_id,
        start_at=now,
        end_at=None,
        start_lat=site.lat,
        start_lng=site.lng,
        end_lat=site.lat,
        end_lng=site.lng,
    )

    db.add(seg)
    db.commit()
    db.refresh(seg)
    return seg


@router.patch("/crew-logs/{log_id}/segments/stop", response_model=CrewSegmentOut)
def stop_open_segment(log_id: int, db: Session = Depends(get_db)):
    _get_log_or_404(db, log_id)

    open_seg = _get_open_segment(db, log_id)
    if not open_seg:
        raise HTTPException(status_code=409, detail="No open segment to close.")

    now = utcnow_naive()
    open_seg.end_at = now

    if open_seg.end_lat is None or open_seg.end_lng is None:
        site = _get_site_or_404(db, open_seg.site_id)
        open_seg.end_lat = site.lat
        open_seg.end_lng = site.lng

    db.commit()
    db.refresh(open_seg)
    return open_seg


@router.patch("/crew-logs/{log_id}/segments/{segment_id}/close", response_model=CrewSegmentOut)
def close_segment(
    log_id: int,
    segment_id: int,
    payload: CrewSegmentClose,
    db: Session = Depends(get_db),
):
    _get_log_or_404(db, log_id)

    seg = (
        db.query(TkCrewWorkSegment)
        .filter(TkCrewWorkSegment.id == segment_id)
        .filter(TkCrewWorkSegment.crew_log_id == log_id)
        .first()
    )
    if not seg:
        raise HTTPException(status_code=404, detail="Segment not found")

    if seg.end_at is not None:
        raise HTTPException(status_code=409, detail="Segment already closed")

    seg.end_at = payload.end_at or utcnow_naive()

    if seg.end_lat is None or seg.end_lng is None:
        site = _get_site_or_404(db, seg.site_id)
        seg.end_lat = site.lat
        seg.end_lng = site.lng

    db.commit()
    db.refresh(seg)
    return seg

from collections import defaultdict

class CrewLogSummaryOut(BaseModel):
    crew_log_id: int
    work_date: date
    vehicle_id: int
    total_minutes: int
    by_site_minutes: dict[int, int]
    by_employee_minutes: dict[int, int]
from collections import defaultdict

class CrewLogSummaryOut(BaseModel):
    crew_log_id: int
    work_date: date
    vehicle_id: int
    total_minutes: int
    by_site_minutes: dict[int, int]
    by_employee_minutes: dict[int, int]


@router.get("/crew-logs/{log_id}/summary", response_model=CrewLogSummaryOut)
def crew_log_summary(log_id: int, db: Session = Depends(get_db)):
    log = db.query(TkCrewLog).filter(TkCrewLog.id == log_id).first()
    if not log:
        raise HTTPException(status_code=404, detail="Crew log not found")

    segs = (
        db.query(TkCrewWorkSegment)
        .filter(TkCrewWorkSegment.crew_log_id == log_id)
        .filter(TkCrewWorkSegment.end_at.isnot(None))
        .order_by(TkCrewWorkSegment.start_at.asc())
        .all()
    )

    by_site = defaultdict(int)
    total = 0

    for seg in segs:
        minutes = int((seg.end_at - seg.start_at).total_seconds() // 60)
        if minutes < 0:
            minutes = 0
        total += minutes
        by_site[int(seg.site_id)] += minutes

    members = (
        db.query(TkCrewLogMember)
        .filter(TkCrewLogMember.crew_log_id == log_id)
        .all()
    )

    by_emp = {int(m.employee_id): int(total) for m in members}

    return CrewLogSummaryOut(
        crew_log_id=log.id,
        work_date=log.work_date,
        vehicle_id=log.vehicle_id,
        total_minutes=int(total),
        by_site_minutes=dict(by_site),
        by_employee_minutes=by_emp,
    )

